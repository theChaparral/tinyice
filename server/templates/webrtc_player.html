<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Player - {{.Stream.Name}}</title>
    <script src="/assets/js/lucide.min.js"></script>
    <style>
        :root {
            --bg: #05070a; --card: rgba(22, 27, 44, 0.6); --border: rgba(255, 255, 255, 0.08);
            --primary: #38bdf8; --secondary: #94a3b8;
        }
        body { 
            font-family: 'Inter', system-ui, -apple-system, sans-serif; 
            background-color: var(--bg); color: #fff; margin: 0; padding: 0; 
            line-height: 1.6; min-height: 100vh; display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at top right, #1e293b, #05070a);
        }
        .player-card { 
            background: var(--card); border: 1px solid var(--border); 
            border-radius: 40px; padding: 4rem; width: 90%; max-width: 600px;
            box-shadow: 0 40px 100px rgba(0,0,0,0.5);
            backdrop-filter: blur(20px); text-align: center;
        }
        .status-badge {
            display: inline-flex; align-items: center; gap: 0.5rem;
            background: rgba(56, 189, 248, 0.1); color: var(--primary);
            padding: 0.5rem 1.25rem; border-radius: 100px; font-size: 0.75rem;
            font-weight: 800; border: 1px solid rgba(56, 189, 248, 0.2);
            margin-bottom: 2rem; text-transform: uppercase;
        }
        h1 { font-size: 2.5rem; font-weight: 900; margin-bottom: 0.5rem; letter-spacing: -0.04em; }
        .mount { color: var(--secondary); font-size: 1rem; margin-bottom: 3rem; font-family: monospace; }
        
        .play-btn { 
            width: 100px; height: 100px; border-radius: 50%; background: #fff; color: #000; 
            border: none; cursor: pointer; display: flex; align-items: center; justify-content: center;
            margin: 0 auto 3rem; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(255,255,255,0.1);
        }
        .play-btn:hover { transform: scale(1.1); background: var(--primary); }
        .play-btn i { width: 40px; height: 40px; }

        .visualizer { width: 100%; height: 100px; margin-top: 2rem; opacity: 0.5; }
        
        #connection-state { font-size: 0.8rem; color: var(--secondary); margin-top: 1rem; text-transform: uppercase; letter-spacing: 0.1em; }

        .debug-panel {
            margin-top: 3rem; padding: 1.5rem; background: rgba(0,0,0,0.3); border-radius: 20px;
            text-align: left; font-family: monospace; font-size: 0.75rem; color: #10b981;
            max-height: 200px; overflow-y: auto; border: 1px solid var(--border);
        }
        .debug-panel div { margin-bottom: 0.25rem; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 0.25rem; }
        .debug-label { color: var(--secondary); font-weight: bold; }
    </style>
</head>
<body>
    <div class="player-card">
        <div class="status-badge">WebRTC Experimental</div>
        <h1>{{.Stream.Name}}</h1>
        <div class="mount">{{.Stream.MountName}}</div>

        <button id="start-btn" class="play-btn" onclick="startWebRTC()">
            <i data-lucide="play"></i>
        </button>

        <div id="connection-state">Ready</div>
        <canvas id="viz" class="visualizer"></canvas>

        <div class="debug-panel" id="debug-log">
            <div><span class="debug-label">[SYSTEM]</span> Debug console initialized.</div>
        </div>
    </div>

    <script>
        lucide.createIcons();
        let pc;
        const mount = "{{.Stream.MountName}}";

        function log(label, msg) {
            const el = document.getElementById('debug-log');
            const div = document.createElement('div');
            div.innerHTML = `<span class="debug-label">[${label}]</span> ${msg}`;
            el.prepend(div);
        }

        async function startWebRTC() {
            const btn = document.getElementById('start-btn');
            const stateEl = document.getElementById('connection-state');
            
            btn.disabled = true;
            stateEl.textContent = "Connecting...";
            log('CORE', 'Starting RTCPeerConnection...');

            pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });

            pc.onicecandidate = (e) => {
                if (e.candidate) log('ICE', `Found candidate: ${e.candidate.protocol} ${e.candidate.address}`);
            };

            pc.onicegatheringstatechange = () => log('ICE', `Gathering State: ${pc.iceGatheringState}`);
            pc.oniceconnectionstatechange = () => log('ICE', `Conn State: ${pc.iceConnectionState}`);
            pc.onsignalingstatechange = () => log('SIG', `Signaling State: ${pc.signalingState}`);

            pc.ontrack = (event) => {
                log('CORE', 'Audio track received!');
                const stream = event.streams[0];
                let audio = document.getElementById('webrtc-audio');
                if (!audio) {
                    audio = document.createElement('audio');
                    audio.id = 'webrtc-audio';
                    audio.style.display = 'none';
                    document.body.appendChild(audio);
                }
                audio.srcObject = stream;
                audio.play().then(() => log('CORE', 'Playback started successfully')).catch(e => log('ERROR', `Playback failed: ${e.message}`));
                initVisualizer(stream);
            };

            pc.onconnectionstatechange = () => {
                stateEl.textContent = pc.connectionState;
                log('CORE', `Connection State: ${pc.connectionState}`);
                if (pc.connectionState === 'connected') {
                    btn.innerHTML = '<i data-lucide="volume-2"></i>';
                    lucide.createIcons();
                }
                if (pc.connectionState === 'failed') {
                    stateEl.textContent = "Connection Failed";
                    btn.disabled = false;
                    btn.innerHTML = '<i data-lucide="refresh-cw"></i>';
                    lucide.createIcons();
                }
            };

            // Add receiver for audio
            pc.addTransceiver('audio', { direction: 'recvonly' });
            log('SIG', 'Added recvonly audio transceiver');

            const offer = await pc.createOffer();
            log('SIG', 'SDP Offer created');
            await pc.setLocalDescription(offer);

            log('HTTP', `Sending offer to server for mount ${mount}...`);
            const response = await fetch(`/webrtc/offer?mount=${encodeURIComponent(mount)}`, {
                method: 'POST',
                body: JSON.stringify(pc.localDescription),
                headers: { 'Content-Type': 'application/json' }
            });

            if (!response.ok) {
                const err = await response.text();
                stateEl.textContent = "Error: " + err;
                log('ERROR', `Signaling failed: ${err}`);
                btn.disabled = false;
                return;
            }

            const answer = await response.json();
            log('SIG', 'SDP Answer received from server');
            await pc.setRemoteDescription(answer);
            log('CORE', 'Remote description set, awaiting ICE...');
        }

        function initVisualizer(stream) {
            const ctx = new AudioContext();
            const src = ctx.createMediaStreamSource(stream);
            const analyzer = ctx.createAnalyser();
            src.connect(analyzer);
            
            const canvas = document.getElementById('viz');
            const cctx = canvas.getContext('2d');
            const bufferLength = analyzer.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);
                analyzer.getByteFrequencyData(dataArray);
                cctx.clearRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / bufferLength) * 2.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2;
                    cctx.fillStyle = '#38bdf8';
                    cctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }
    </script>
</body>
</html>
